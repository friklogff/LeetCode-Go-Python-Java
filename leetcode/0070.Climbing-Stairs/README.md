# [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)


## 题目

You are climbing a stair case. It takes *n* steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note:** Given *n* will be a positive integer.

**Example 1:**

    Input: 2
    Output: 2
    Explanation: There are two ways to climb to the top.
    1. 1 step + 1 step
    2. 2 steps

**Example 2:**

    Input: 3
    Output: 3
    Explanation: There are three ways to climb to the top.
    1. 1 step + 1 step + 1 step
    2. 1 step + 2 steps
    3. 2 steps + 1 step


## 题目大意

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数


## 解题思路

- 简单的 DP，经典的爬楼梯问题。一个楼梯可以由 `n-1` 和 `n-2` 的楼梯爬上来。
- 这一题求解的值就是斐波那契数列。
当解决LeetCode上的爬楼梯问题时，每个版本的解题思路都基本相同，使用了动态规划的思想，将问题拆分为子问题并存储中间结果以提高效率。以下是每个版本的解题思路的详细介绍：

Go 版本解题思路

1. 创建一个长度为 n+1 的整数切片 dp，用于存储每个台阶对应的爬楼方法数。

2. 初始化 dp 切片的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1。

3. 从第三个台阶开始，使用循环依次计算每个台阶的爬楼方法数。每个台阶的爬楼方法数等于前两个台阶的爬楼方法数之和。

4. 最后返回爬到第 n 个台阶的方法数，即 dp 切片的最后一个元素。

这个思路将问题分解成了子问题，避免了重复计算，提高了效率。

Python 版本解题思路

1. 创建一个长度为 n+1 的列表 dp，用于存储每个台阶对应的爬楼方法数。

2. 初始化 dp 列表的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1。

3. 从第三个台阶开始，使用循环依次计算每个台阶的爬楼方法数。每个台阶的爬楼方法数等于前两个台阶的爬楼方法数之和。

4. 最后返回爬到第 n 个台阶的方法数，即 dp 列表的最后一个元素。

这个思路与Go版本类似，使用了相同的动态规划方法来解决问题。

Java 版本解题思路

1. 创建一个长度为 n+1 的整数数组 dp，用于存储每个台阶对应的爬楼方法数。

2. 初始化 dp 数组的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1。

3. 从第三个台阶开始，使用循环依次计算每个台阶的爬楼方法数。每个台阶的爬楼方法数等于前两个台阶的爬楼方法数之和。

4. 最后返回爬到第 n 个台阶的方法数，即 dp 数组的最后一个元素。

这个思路与Go和Python版本相似，但使用了Java特定的语法和数组结构。

C++ 版本解题思路

1. 创建一个长度为 n+1 的整数向量 dp，用于存储每个台阶对应的爬楼方法数。

2. 初始化 dp 向量的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1。

3. 从第三个台阶开始，使用循环依次计算每个台阶的爬楼方法数。每个台阶的爬楼方法数等于前两个台阶的爬楼方法数之和。

4. 最后返回爬到第 n 个台阶的方法数，即 dp 向量的最后一个元素。

这个思路与Go、Python和Java版本类似，但使用了C++特定的语法和向量数据结构。
## 代码

## Go

```Go
func climbStairs(n int) int {
    // 创建一个长度为 n+1 的整数切片 dp，用于存储每个台阶对应的爬楼方法数
    dp := make([]int, n+1)
    
    // 初始化 dp 切片的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1
    dp[0], dp[1] = 1, 1
    
    // 从第三个台阶开始，依次计算每个台阶的爬楼方法数
    for i := 2; i <= n; i++ {
        // 当前台阶的爬楼方法数等于前两个台阶的爬楼方法数之和
        dp[i] = dp[i-1] + dp[i-2]
    }
    
    // 返回爬到第 n 个台阶的方法数，即 dp 切片的最后一个元素
    return dp[n]
}

```

## Python

```Python
class Solution:
    def climbStairs(self, n: int) -> int:
        # 创建一个长度为 n+1 的列表 dp，用于存储每个台阶对应的爬楼方法数
        dp = [0] * (n + 1)
        
        # 初始化 dp 列表的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1
        dp[0], dp[1] = 1, 1
        
        # 从第三个台阶开始，依次计算每个台阶的爬楼方法数
        for i in range(2, n + 1):
            # 当前台阶的爬楼方法数等于前两个台阶的爬楼方法数之和
            dp[i] = dp[i - 1] + dp[i - 2]
        
        # 返回爬到第 n 个台阶的方法数，即 dp 列表的最后一个元素
        return dp[n]
```

## Java

```Java
class Solution {
    public int climbStairs(int n) {
        // 创建一个长度为 n+1 的数组 dp，用于存储每个台阶对应的爬楼方法数
        int[] dp = new int[n + 1];
        
        // 初始化 dp 数组的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1
        dp[0] = 1;
        dp[1] = 1;
        
        // 从第三个台阶开始，依次计算每个台阶的爬楼方法数
        for (int i = 2; i <= n; i++) {
            // 当前台阶的爬楼方法数等于前两个台阶的爬楼方法数之和
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        // 返回爬到第 n 个台阶的方法数，即 dp 数组的最后一个元素
        return dp[n];
    }
}

```

## Cpp

```Cpp
class Solution {
public:
    int climbStairs(int n) {
        // 创建一个长度为 n+1 的数组 dp，用于存储每个台阶对应的爬楼方法数
        vector<int> dp(n + 1, 0);
        
        // 初始化 dp 数组的前两个元素为 1，因为爬到第一个台阶和第二个台阶的方法数都是 1
        dp[0] = 1;
        dp[1] = 1;
        
        // 从第三个台阶开始，依次计算每个台阶的爬楼方法数
        for (int i = 2; i <= n; i++) {
            // 当前台阶的爬楼方法数等于前两个台阶的爬楼方法数之和
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        // 返回爬到第 n 个台阶的方法数，即 dp 数组的最后一个元素
        return dp[n];
    }
};

```

当使用不同的编程语言来解决LeetCode上的爬楼梯问题时，需要了解一些基础知识，包括语言特定的语法和数据结构。以下是每个版本的所需基础知识的详细介绍：

Go 版本

1. **包导入和函数声明：** 在Go中，您需要了解如何导入包和声明函数。代码中使用的`func climbStairs(n int) int`是一个函数声明的示例，其中`int`是参数类型，后面的`int`是返回值类型。

2. **切片（Slices）：** Go使用切片来动态分配数组，您需要了解如何创建和初始化切片，以及如何访问和修改切片中的元素。在这个示例中，切片用于存储爬楼方法数。

3. **循环：** 您需要了解如何使用`for`循环来迭代数组或切片。在这里，循环用于计算每个楼梯的爬楼方法数。

Python 版本

1. **类和方法：** Python中的解决方法可以定义为类的方法。您需要了解如何声明类和方法。在这个示例中，`climbStairs`是一个类方法，接受参数`n`。

2. **列表（Lists）：** Python中的列表用于存储数据。您需要了解如何创建和初始化列表，以及如何访问和修改列表中的元素。在这个示例中，列表用于存储爬楼方法数。

3. **循环：** 您需要了解如何使用`for`循环来迭代列表或其他可迭代对象。在这里，循环用于计算每个楼梯的爬楼方法数。

Java 版本

1. **类和方法：** Java中使用类和方法来组织代码。您需要了解如何声明类和方法。在这个示例中，`Solution`是一个类，`climbStairs`是一个方法，接受参数`n`。

2. **数组：** Java中使用数组来存储数据。您需要了解如何声明和初始化数组，以及如何访问和修改数组中的元素。在这个示例中，数组用于存储爬楼方法数。

3. **循环：** 您需要了解如何使用`for`循环来迭代数组或其他可迭代对象。在这里，循环用于计算每个楼梯的爬楼方法数。

C++ 版本

1. **类和方法：** C++中也可以使用类和方法来组织代码。您需要了解如何声明类和方法。在这个示例中，`Solution`是一个类，`climbStairs`是一个方法，接受参数`n`。

2. **向量（Vectors）：** C++中的向量类似于动态数组，用于存储数据。您需要了解如何声明和初始化向量，以及如何访问和修改向量中的元素。在这个示例中，向量用于存储爬楼方法数。

3. **循环：** 您需要了解如何使用`for`循环来迭代向量或其他可迭代对象。在这里，循环用于计算每个楼梯的爬楼方法数。

除了上述语言特定的知识，您还需要了解动态规划的基本概念，特别是在这个问题中，它涉及到计算爬楼梯的方法数时如何使用动态规划和Fibonacci序列。熟悉这些语言和算法概念将帮助您理解和编写这个问题的解决方案。