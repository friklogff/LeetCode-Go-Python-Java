# [64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)


## 题目

Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example:**

    Input:
    [
      [1,3,1],
      [1,5,1],
      [4,2,1]
    ]
    Output: 7
    Explanation: Because the path 1→3→1→1→1 minimizes the sum.

## 题目大意

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。


## 解题思路

- 在地图上求出从左上角到右下角的路径中，数字之和最小的一个，输出数字和。
- 这一题最简单的想法就是用一个二维数组来 DP，当然这是最原始的做法。由于只能往下和往右走，只需要维护 2 列信息就可以了，从左边推到最右边即可得到最小的解。更近一步，可以直接在原来的数组中做原地 DP，空间复杂度为 0 。
以下是每个版本的解题思路的详细介绍：

Go 版本解题思路

1. 首先，获取网格的行数 `m` 和列数 `n`。

2. 创建一个一维数组 `dp`，用于存储从起点到每个位置的最小路径和。将 `dp[0]` 初始化为起点的值，即 `grid[0][0]`。

3. 遍历第一行，计算每个位置的最小路径和并存储在 `dp` 数组中。这是因为只能向右移动，所以第一行的最小路径和只能从左向右递增。

4. 遍历剩余的行和列：
   - 如果当前位置是第一列，只能从上方移动到达，因此更新 `dp[0]` 的值。
   - 如果当前位置不是第一列，计算从上方和左方两个方向到达当前位置的最小路径和，并更新 `dp` 数组的值。

5. 最后一个元素 `dp[n-1]` 存储了从起点到终点的最小路径和，返回它作为最终答案。

Python 版本解题思路

1. 获取网格的行数 `m` 和列数 `n`。

2. 创建一个二维数组 `dp`，用于存储从起点到每个位置的最小路径和。将 `dp[0][0]` 初始化为起点的值，即 `grid[0][0]`。

3. 初始化 `dp` 数组的第一行和第一列，分别表示从起点出发到达第一行和第一列各个位置的最小路径和。这是因为只能向右或向下移动，所以第一行和第一列的最小路径和只能递增。

4. 遍历剩余的行和列：
   - 对于位置 `(i, j)`，计算从上方 `(i-1, j)` 和左方 `(i, j-1)` 到达当前位置的最小路径和，然后将最小值与当前位置的值相加，更新 `dp[i][j]`。

5. 最后一个元素 `dp[m-1][n-1]` 存储了从起点到终点的最小路径和，返回它作为最终答案。

Java 版本解题思路

1. 获取网格的行数 `m` 和列数 `n`。

2. 创建一个二维数组 `dp`，用于存储从起点到每个位置的最小路径和。将 `dp[0][0]` 初始化为起点的值，即 `grid[0][0]`。

3. 初始化 `dp` 数组的第一行和第一列，分别表示从起点出发到达第一行和第一列各个位置的最小路径和。这是因为只能向右或向下移动，所以第一行和第一列的最小路径和只能递增。

4. 使用嵌套的 `for` 循环遍历剩余的行和列：
   - 对于位置 `(i, j)`，计算从上方 `(i-1, j)` 和左方 `(i, j-1)` 到达当前位置的最小路径和，然后将最小值与当前位置的值相加，更新 `dp[i][j]`。

5. 最后一个元素 `dp[m-1][n-1]` 存储了从起点到终点的最小路径和，返回它作为最终答案。

C++ 版本解题思路

1. 获取网格的行数 `m` 和列数 `n`。

2. 创建一个二维数组 `dp`，用于存储从起点到每个位置的最小路径和。将 `dp[0][0]` 初始化为起点的值，即 `grid[0][0]`。

3. 初始化 `dp` 数组的第一行和第一列，分别表示从起点出发到达第一行和第一列各个位置的最小路径和。这是因为只能向右或向下移动，所以第一行和第一列的最小路径和只能递增。

4. 使用嵌套的 `for` 循环遍历剩余的行和列：
   - 对于位置 `(i, j)`，计算从上方 `(i-1, j)` 和左方 `(i, j-1)` 到达当前位置的最小路径和，然后将最小值与当前位置的值相加，更新 `dp[i][j]`。

5. 最后一个元素 `dp[m-1][n-1]` 存储了从起点到终点的最小路径和，返回它作为最终答案。

无论使用哪种编程语言，上述解题思路的核心思想都是利用动态规划，从左上角开始逐步计算并更新到达每个位置的最小路径和，最终得到最小路径和的答案。
## 代码

## Go

```Go
// 定义一个函数minPathSum，它接受一个二维整数网格grid作为参数，返回最小路径和的整数。
func minPathSum(grid [][]int) int {
	// 获取网格的行数m
	m := len(grid)
	// 如果网格行数为0，直接返回0
	if m == 0 {
		return 0
	}
	// 获取网格的列数n
	n := len(grid[0])
	// 创建一个一维数组dp，用于存储从起点到每个位置的最小路径和
	dp := make([]int, n)
	// 初始化dp数组的第一个元素为起点的值
	dp[0] = grid[0][0]
	// 遍历第一行，计算每个位置的最小路径和并存储在dp数组中
	for i := 1; i < n; i++ {
		dp[i] = grid[0][i] + dp[i-1]
	}
	// 遍历剩余行
	for i := 1; i < m; i++ {
		for j := 0; j < n; j++ {
			if j == 0 {
				// 如果当前位置是第一列，只能从上方移动到达，更新dp数组的值
				dp[0] = dp[0] + grid[i][0]
				continue
			}
			// 如果当前位置不是第一列，计算从上方和左方两个方向到达当前位置的最小路径和，并更新dp数组的值
			dp[j] = min(dp[j-1], dp[j]) + grid[i][j]
		}
	}
	// 最后一个元素dp[n-1]存储了从起点到终点的最小路径和，返回它
	return dp[n-1]
}

// 定义一个辅助函数min，用于比较两个整数的大小并返回较小的那个整数。
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

```

## Python

```Python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 获取网格的行数m和列数n
        m = len(grid)
        n = len(grid[0])
        
        # 创建一个二维数组dp，用于存储从起点到每个位置的最小路径和
        dp = [[0] * n for _ in range(m)]
        
        # 初始化dp数组的第一个元素为起点的值
        dp[0][0] = grid[0][0]
        
        # 初始化第一行和第一列的最小路径和
        for i in range(1, m):
            dp[i][0] = dp[i-1][0] + grid[i][0]
        for j in range(1, n):
            dp[0][j] = dp[0][j-1] + grid[0][j]
        
        # 遍历剩余网格，计算每个位置的最小路径和
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
        
        # 返回终点的最小路径和
        return dp[m-1][n-1]

```

## Java

```Java
class Solution {
    public int minPathSum(int[][] grid) {
        // 获取网格的行数m和列数n
        int m = grid.length;
        int n = grid[0].length;
        
        // 创建一个二维数组dp，用于存储从起点到每个位置的最小路径和
        int[][] dp = new int[m][n];
        
        // 初始化dp数组的第一个元素为起点的值
        dp[0][0] = grid[0][0];
        
        // 初始化第一行和第一列的最小路径和
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        
        // 遍历剩余网格，计算每个位置的最小路径和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        
        // 返回终点的最小路径和
        return dp[m-1][n-1];
    }
}

```

## Cpp

```Cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        // 获取网格的行数m和列数n
        int m = grid.size();
        int n = grid[0].size();
        
        // 创建一个二维数组dp，用于存储从起点到每个位置的最小路径和
        vector<vector<int>> dp(m, vector<int>(n, 0));
        
        // 初始化dp数组的第一个元素为起点的值
        dp[0][0] = grid[0][0];
        
        // 初始化第一行和第一列的最小路径和
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        
        // 遍历剩余网格，计算每个位置的最小路径和
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        
        // 返回终点的最小路径和
        return dp[m-1][n-1];
    }
};

```
好的，让我为每个版本的代码提供更详细的基础知识解释。

Go 版本解释

这是 Go 语言版本的解决方案，需要掌握以下基础知识：

1. **切片 (Slices)**：Go 中的切片是可变长度的序列，通常用于处理动态数组。在这个解决方案中，我们使用切片来存储 `dp` 数组。

2. **循环 (Loops)**：在 Go 中，通常使用 `for` 循环来迭代数组或切片的元素。在这个解决方案中，我们使用 `for` 循环来遍历二维数组，计算最小路径和。

3. **条件语句 (Conditional Statements)**：Go 中的条件语句（如 `if` 语句）用于根据条件执行不同的代码块。在这个解决方案中，我们使用条件语句来处理特殊情况，例如处理第一行和第一列的元素。

4. **函数 (Functions)**：在 Go 中，函数是可以独立调用的代码块。在这个解决方案中，我们定义了一个用于计算最小路径和的函数 `minPathSum`。

Python 版本解释

这是 Python 版本的解决方案，需要掌握以下基础知识：

1. **列表 (Lists)**：在 Python 中，列表是可变的有序序列，通常用于存储多个值。在这个解决方案中，我们使用列表来表示 `dp` 数组。

2. **循环 (Loops)**：Python 使用 `for` 循环来遍历列表、数组或其他可迭代对象的元素。在这个解决方案中，我们使用 `for` 循环来遍历二维数组，并计算最小路径和。

3. **条件语句 (Conditional Statements)**：Python 中的条件语句（如 `if` 语句）用于根据条件执行不同的代码块。在这个解决方案中，我们使用条件语句来处理特殊情况，例如处理第一行和第一列的元素。

4. **类 (Classes)**：在这个解决方案中，我们使用了类来定义 `Solution` 类，其中包含了计算最小路径和的方法 `minPathSum`。这是一种面向对象的编程方式。

Java 版本解释

这是 Java 版本的解决方案，需要掌握以下基础知识：

1. **数组 (Arrays)**：Java 中的数组是固定大小的数据结构，用于存储多个相同类型的元素。在这个解决方案中，我们使用二维数组来表示 `grid` 和 `dp` 数组。

2. **循环 (Loops)**：Java 使用 `for` 循环来遍历数组或集合中的元素。在这个解决方案中，我们使用嵌套的 `for` 循环来遍历二维数组，并计算最小路径和。

3. **条件语句 (Conditional Statements)**：Java 中的条件语句（如 `if` 语句）用于根据条件执行不同的代码块。在这个解决方案中，我们使用条件语句来处理特殊情况，例如处理第一行和第一列的元素。

4. **类 (Classes)**：在这个解决方案中，我们使用了类来定义 `Solution` 类，其中包含了计算最小路径和的方法 `minPathSum`。这是一种面向对象的编程方式。

C++ 版本解释

这是 C++ 版本的解决方案，需要掌握以下基础知识：

1. **数组 (Arrays)**：C++ 中的数组是固定大小的数据结构，用于存储多个相同类型的元素。在这个解决方案中，我们使用二维数组来表示 `grid` 和 `dp` 数组。

2. **循环 (Loops)**：C++ 使用 `for` 循环来遍历数组或集合中的元素。在这个解决方案中，我们使用嵌套的 `for` 循环来遍历二维数组，并计算最小路径和。

3. **条件语句 (Conditional Statements)**：C++ 中的条件语句（如 `if` 语句）用于根据条件执行不同的代码块。在这个解决方案中，我们使用条件语句来处理特殊情况，例如处理第一行和第一列的元素。

4. **类 (Classes)**：在这个解决方案中，我们没有使用类，而是直接定义了一个全局的 `Solution` 函数，其中包含了计算最小路径和的代码。

总之，无论使用哪种编程语言，理解和掌握数组、循环、条件语句和函数/类的基本概念是解决这个问题的关键。此外，了解动态规划的基本原理也对理解这些解决方案非常有帮助。
